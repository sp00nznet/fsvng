#include "TextRenderer.h"
#include "Renderer.h"

#include <glm/gtc/matrix_transform.hpp>
#include <cmath>
#include <cstring>
#include <iostream>
#include <vector>

namespace fsvng {

// ---------------------------------------------------------------------------
// Embedded minimal 8x16 bitmap font data (CP437-style, ASCII 32-126)
// Each character is 16 bytes, one byte per row, MSB = leftmost pixel.
// Only printable ASCII (32-126) is defined; all other entries are blank.
// ---------------------------------------------------------------------------
// clang-format off
static const unsigned char kFontBitmap[][16] = {
    // 32: space
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 33: !
    {0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 34: "
    {0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 35: #
    {0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00},
    // 36: $
    {0x00,0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00},
    // 37: %
    {0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00},
    // 38: &
    {0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 39: '
    {0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 40: (
    {0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00},
    // 41: )
    {0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00},
    // 42: *
    {0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00},
    // 43: +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00},
    // 44: ,
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00},
    // 45: -
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 46: .
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 47: /
    {0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00},
    // 48: 0
    {0x00,0x00,0x7C,0xC6,0xC6,0xCE,0xDE,0xF6,0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 49: 1
    {0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00},
    // 50: 2
    {0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00},
    // 51: 3
    {0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 52: 4
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00},
    // 53: 5
    {0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 54: 6
    {0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 55: 7
    {0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00},
    // 56: 8
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 57: 9
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00},
    // 58: :
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 59: ;
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00},
    // 60: <
    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00},
    // 61: =
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 62: >
    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00},
    // 63: ?
    {0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 64: @
    {0x00,0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00},
    // 65: A
    {0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 66: B
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00},
    // 67: C
    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 68: D
    {0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00},
    // 69: E
    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00},
    // 70: F
    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 71: G
    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00},
    // 72: H
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 73: I
    {0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 74: J
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00},
    // 75: K
    {0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 76: L
    {0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00},
    // 77: M
    {0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 78: N
    {0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 79: O
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 80: P
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 81: Q
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00},
    // 82: R
    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 83: S
    {0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 84: T
    {0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 85: U
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 86: V
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00},
    // 87: W
    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00},
    // 88: X
    {0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00},
    // 89: Y
    {0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 90: Z
    {0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00},
    // 91: [
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00},
    // 92: backslash
    {0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00},
    // 93: ]
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00},
    // 94: ^
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 95: _
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
    // 96: `
    {0x00,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 97: a
    {0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 98: b
    {0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00},
    // 99: c
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 100: d
    {0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 101: e
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 102: f
    {0x00,0x00,0x1C,0x36,0x32,0x30,0x78,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00},
    // 103: g
    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00},
    // 104: h
    {0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 105: i
    {0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 106: j
    {0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00},
    // 107: k
    {0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00},
    // 108: l
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00},
    // 109: m
    {0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00},
    // 110: n
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00},
    // 111: o
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 112: p
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00},
    // 113: q
    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00},
    // 114: r
    {0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00},
    // 115: s
    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00},
    // 116: t
    {0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00},
    // 117: u
    {0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00},
    // 118: v
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00},
    // 119: w
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00},
    // 120: x
    {0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00},
    // 121: y
    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00},
    // 122: z
    {0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00},
    // 123: {
    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00},
    // 124: |
    {0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00},
    // 125: }
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00},
    // 126: ~
    {0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};
// clang-format on

static constexpr int kFontGlyphCount = 95; // ASCII 32..126

TextRenderer& TextRenderer::instance() {
    static TextRenderer inst;
    return inst;
}

void TextRenderer::init() {
    if (initialized_) {
        return;
    }

    buildFontAtlas();
    initialized_ = true;

    std::cout << "TextRenderer: Initialized" << std::endl;
}

void TextRenderer::shutdown() {
    if (!initialized_) {
        return;
    }

    textMesh_.destroy();

    if (fontTexture_ != 0) {
        glDeleteTextures(1, &fontTexture_);
        fontTexture_ = 0;
    }

    initialized_ = false;

    std::cout << "TextRenderer: Shut down" << std::endl;
}

void TextRenderer::buildFontAtlas() {
    // Create a 256x256 single-channel texture atlas.
    // Each character occupies an 8x16 cell.
    // Characters are laid out in a grid: 32 chars per row, 16 rows.
    // ASCII 32-126 fill positions 0..94 in the grid.

    std::vector<unsigned char> atlas(kAtlasWidth * kAtlasHeight, 0);

    for (int i = 0; i < kFontGlyphCount; ++i) {
        int ch = 32 + i; // ASCII code
        int gridX = i % kCharsPerRow;
        int gridY = i / kCharsPerRow;

        int baseX = gridX * kCharWidth;
        int baseY = gridY * kCharHeight;

        for (int row = 0; row < kCharHeight; ++row) {
            unsigned char bits = kFontBitmap[i][row];
            for (int col = 0; col < kCharWidth; ++col) {
                bool on = (bits >> (7 - col)) & 1;
                int px = baseX + col;
                int py = baseY + row;
                atlas[static_cast<size_t>(py * kAtlasWidth + px)] = on ? 255 : 0;
            }
        }

        // Fill in CharInfo UV coordinates (normalized)
        float u0 = static_cast<float>(baseX) / static_cast<float>(kAtlasWidth);
        float v0 = static_cast<float>(baseY) / static_cast<float>(kAtlasHeight);
        float u1 = static_cast<float>(baseX + kCharWidth) / static_cast<float>(kAtlasWidth);
        float v1 = static_cast<float>(baseY + kCharHeight) / static_cast<float>(kAtlasHeight);

        charInfo_[ch].x0 = u0;
        charInfo_[ch].y0 = v0;
        charInfo_[ch].x1 = u1;
        charInfo_[ch].y1 = v1;
        charInfo_[ch].width = static_cast<float>(kCharWidth);
        charInfo_[ch].advance = static_cast<float>(kCharWidth);

        (void)ch; // suppress unused variable warning in release
    }

    charHeight_ = static_cast<float>(kCharHeight);

    // Create OpenGL texture
    glGenTextures(1, &fontTexture_);
    glBindTexture(GL_TEXTURE_2D, fontTexture_);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8,
                 kAtlasWidth, kAtlasHeight, 0,
                 GL_RED, GL_UNSIGNED_BYTE, atlas.data());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    glBindTexture(GL_TEXTURE_2D, 0);
}

void TextRenderer::drawText3D(const std::string& text, const glm::vec3& position,
                               float scale, const glm::vec3& color) {
    if (!initialized_ || text.empty()) {
        return;
    }

    // Build quads for each character
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    vertices.reserve(text.size() * 4);
    indices.reserve(text.size() * 6);

    float cursorX = 0.0f;
    uint32_t baseIdx = 0;

    float scaledHeight = charHeight_ * scale;

    for (char c : text) {
        int ch = static_cast<unsigned char>(c);
        if (ch < 32 || ch > 126) {
            ch = 32; // replace unprintable with space
        }

        const CharInfo& ci = charInfo_[ch];
        float scaledWidth = ci.width * scale;

        // Quad corners (in local space, will be offset by position via model matrix)
        float x0 = cursorX;
        float x1 = cursorX + scaledWidth;
        float y0 = 0.0f;
        float y1 = scaledHeight;

        // Bottom-left
        Vertex v0;
        v0.position = glm::vec3(x0, y0, 0.0f);
        v0.normal = glm::vec3(0.0f, 0.0f, 1.0f);
        v0.color = color;
        v0.texcoord = glm::vec2(ci.x0, ci.y1);

        // Bottom-right
        Vertex v1;
        v1.position = glm::vec3(x1, y0, 0.0f);
        v1.normal = glm::vec3(0.0f, 0.0f, 1.0f);
        v1.color = color;
        v1.texcoord = glm::vec2(ci.x1, ci.y1);

        // Top-right
        Vertex v2;
        v2.position = glm::vec3(x1, y1, 0.0f);
        v2.normal = glm::vec3(0.0f, 0.0f, 1.0f);
        v2.color = color;
        v2.texcoord = glm::vec2(ci.x1, ci.y0);

        // Top-left
        Vertex v3;
        v3.position = glm::vec3(x0, y1, 0.0f);
        v3.normal = glm::vec3(0.0f, 0.0f, 1.0f);
        v3.color = color;
        v3.texcoord = glm::vec2(ci.x0, ci.y0);

        vertices.push_back(v0);
        vertices.push_back(v1);
        vertices.push_back(v2);
        vertices.push_back(v3);

        // Two triangles per quad
        indices.push_back(baseIdx + 0);
        indices.push_back(baseIdx + 1);
        indices.push_back(baseIdx + 2);
        indices.push_back(baseIdx + 0);
        indices.push_back(baseIdx + 2);
        indices.push_back(baseIdx + 3);

        baseIdx += 4;
        cursorX += ci.advance * scale;
    }

    // Upload mesh data
    textMesh_.uploadDynamic(vertices, indices);

    // Set up the text shader
    ShaderProgram& shader = Renderer::instance().getTextShader();
    shader.use();

    glm::mat4 model = glm::translate(glm::mat4(1.0f), position);
    shader.setMat4("uModel", model);
    shader.setVec3("uTextColor", color);
    shader.setInt("uFontAtlas", 0);

    // Bind font atlas
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, fontTexture_);

    // Disable depth writing for text overlay but still test depth
    glDepthMask(GL_FALSE);

    textMesh_.draw(GL_TRIANGLES);

    glDepthMask(GL_TRUE);

    glBindTexture(GL_TEXTURE_2D, 0);
    shader.unuse();
}

void TextRenderer::drawTextCurved(const std::string& text, const glm::vec3& center,
                                   float radius, float startAngle, float scale,
                                   const glm::vec3& color) {
    if (!initialized_ || text.empty()) {
        return;
    }

    // Build quads for each character placed along a circular arc
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;
    vertices.reserve(text.size() * 4);
    indices.reserve(text.size() * 6);

    float scaledHeight = charHeight_ * scale;

    // Compute the angular advance per character based on arc length
    // Arc length for one character = charWidth * scale
    // angle = arcLength / radius
    float currentAngle = startAngle;
    uint32_t baseIdx = 0;

    for (char c : text) {
        int ch = static_cast<unsigned char>(c);
        if (ch < 32 || ch > 126) {
            ch = 32;
        }

        const CharInfo& ci = charInfo_[ch];
        float scaledWidth = ci.width * scale;
        float angularWidth = scaledWidth / radius;

        float midAngle = currentAngle + angularWidth * 0.5f;

        // Position on the arc (XZ plane, Y is up)
        float cx = center.x + radius * std::cos(midAngle);
        float cz = center.z + radius * std::sin(midAngle);

        // Tangent direction (perpendicular to radius in XZ plane)
        float tx = -std::sin(midAngle);
        float tz = std::cos(midAngle);

        // Normal points outward (away from center)
        float nx = std::cos(midAngle);
        float nz = std::sin(midAngle);

        float halfW = scaledWidth * 0.5f;

        // Four corners of the character quad
        // Bottom-left
        Vertex v0;
        v0.position = glm::vec3(cx - tx * halfW, center.y, cz - tz * halfW);
        v0.normal = glm::vec3(nx, 0.0f, nz);
        v0.color = color;
        v0.texcoord = glm::vec2(ci.x0, ci.y1);

        // Bottom-right
        Vertex v1;
        v1.position = glm::vec3(cx + tx * halfW, center.y, cz + tz * halfW);
        v1.normal = glm::vec3(nx, 0.0f, nz);
        v1.color = color;
        v1.texcoord = glm::vec2(ci.x1, ci.y1);

        // Top-right
        Vertex v2;
        v2.position = glm::vec3(cx + tx * halfW, center.y + scaledHeight, cz + tz * halfW);
        v2.normal = glm::vec3(nx, 0.0f, nz);
        v2.color = color;
        v2.texcoord = glm::vec2(ci.x1, ci.y0);

        // Top-left
        Vertex v3;
        v3.position = glm::vec3(cx - tx * halfW, center.y + scaledHeight, cz - tz * halfW);
        v3.normal = glm::vec3(nx, 0.0f, nz);
        v3.color = color;
        v3.texcoord = glm::vec2(ci.x0, ci.y0);

        vertices.push_back(v0);
        vertices.push_back(v1);
        vertices.push_back(v2);
        vertices.push_back(v3);

        indices.push_back(baseIdx + 0);
        indices.push_back(baseIdx + 1);
        indices.push_back(baseIdx + 2);
        indices.push_back(baseIdx + 0);
        indices.push_back(baseIdx + 2);
        indices.push_back(baseIdx + 3);

        baseIdx += 4;
        currentAngle += angularWidth;
    }

    // Upload and draw
    textMesh_.uploadDynamic(vertices, indices);

    ShaderProgram& shader = Renderer::instance().getTextShader();
    shader.use();

    // Model matrix is identity since positions are already in world space
    shader.setMat4("uModel", glm::mat4(1.0f));
    shader.setVec3("uTextColor", color);
    shader.setInt("uFontAtlas", 0);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, fontTexture_);

    glDepthMask(GL_FALSE);

    textMesh_.draw(GL_TRIANGLES);

    glDepthMask(GL_TRUE);

    glBindTexture(GL_TEXTURE_2D, 0);
    shader.unuse();
}

float TextRenderer::getTextWidth(const std::string& text, float scale) const {
    float width = 0.0f;
    for (char c : text) {
        int ch = static_cast<unsigned char>(c);
        if (ch < 32 || ch > 126) {
            ch = 32;
        }
        width += charInfo_[ch].advance * scale;
    }
    return width;
}

} // namespace fsvng
